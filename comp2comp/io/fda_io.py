"""
@author: louisblankemeier
"""

import os
import shutil
from pathlib import Path
from typing import Dict, Union

# import dicom2nifti
import dosma as dm
import pydicom
import SimpleITK as sitk

from comp2comp.inference_class_base import InferenceClass


class DicomLoader(InferenceClass):
    """Load a single dicom series."""

    def __init__(self, input_path: Union[str, Path]):
        super().__init__()
        self.dicom_dir = Path(input_path)
        self.dr = dm.DicomReader()

    def __call__(self, inference_pipeline) -> Dict:
        medical_volume = self.dr.load(
            self.dicom_dir, group_by=None, sort_by="InstanceNumber"
        )[0]
        return {"medical_volume": medical_volume}


class NiftiSaver(InferenceClass):
    """Save dosma medical volume object to NIfTI file."""

    def __init__(self):
        super().__init__()
        # self.output_dir = Path(output_path)
        self.nw = dm.NiftiWriter()

    def __call__(
        self, inference_pipeline, medical_volume: dm.MedicalVolume
    ) -> Dict[str, Path]:
        nifti_file = inference_pipeline.output_dir
        self.nw.write(medical_volume, nifti_file)
        return {"nifti_file": nifti_file}


class DicomFinder(InferenceClass):
    """Find dicom files in a directory."""

    def __init__(self, input_path: Union[str, Path]) -> Dict[str, Path]:
        super().__init__()
        self.input_path = Path(input_path)

    def __call__(self, inference_pipeline) -> Dict[str, Path]:
        """Find dicom files in a directory.

        Args:
            inference_pipeline (InferencePipeline): Inference pipeline.

        Returns:
            Dict[str, Path]: Dictionary containing dicom files.
        """
        dicom_files = []
        for file in self.input_path.glob("**/*.dcm"):
            dicom_files.append(file)
        inference_pipeline.dicom_file_paths = dicom_files
        return {}


class DicomToNifti(InferenceClass):
    """Convert dicom files to NIfTI files."""

    def __init__(self, input_path: Union[str, Path], pipeline_name=None, save=True):
        super().__init__()
        self.input_path = Path(input_path)
        self.save = save
        self.pipeline_name = pipeline_name

    def __call__(self, inference_pipeline):
        if os.path.exists(
            os.path.join(
                inference_pipeline.output_dir, "segmentations", "converted_dcm.nii.gz"
            )
        ):
            return {}
        if hasattr(inference_pipeline, "medical_volume"):
            return {}
        output_dir = inference_pipeline.output_dir
        segmentations_output_dir = os.path.join(output_dir, "segmentations")
        os.makedirs(segmentations_output_dir, exist_ok=True)

        # if self.input_path is a folder
        if self.input_path.is_dir():
            ds = dicom_series_to_nifti(
                self.input_path,
                output_file=os.path.join(
                    segmentations_output_dir, "converted_dcm.nii.gz"
                ),
                reorient_nifti=False,
                pipeline_name=self.pipeline_name,
            )
            inference_pipeline.dicom_series_path = str(self.input_path)
            inference_pipeline.dicom_ds = ds
            # try:
            # age = np.array(ds.loc[ds['Keyword'] == 'PatientAge']['Value'])[0]
            # inference_pipeline.age = int(age.replace('Y', ''))
            try:
                age = ds.PatientAge
                inference_pipeline.age = int(age.replace("Y", ""))
            except:
                inference_pipeline.age = 65
        elif str(self.input_path).endswith(".nii"):
            shutil.copy(
                self.input_path,
                os.path.join(segmentations_output_dir, "converted_dcm.nii"),
            )
        elif str(self.input_path).endswith(".nii.gz"):
            shutil.copy(
                self.input_path,
                os.path.join(segmentations_output_dir, "converted_dcm.nii.gz"),
            )

        return {}


def series_selector(dicom_path, pipeline_name=None):
    ds = pydicom.filereader.dcmread(dicom_path)
    list(ds.ImageType)
    # if pipeline_name != "aaa":
    #     if not any("primary" in s.lower() for s in image_type_list):
    #         raise ValueError("Not primary image type")
    #     if not any("original" in s.lower() for s in image_type_list):
    #         raise ValueError("Not original image type")
    #     if ds.ImageOrientationPatient != [1, 0, 0, 0, 1, 0]:
    #         raise ValueError("Image orientation is not axial")
    # else:
    #     print(f"Skipping primary, original, and orientation image type check for the {pipeline_name} pipeline.")
    # if any("gsi" in s.lower() for s in image_type_list):
    #     raise ValueError("GSI image type")
    return ds


# def dicom_series_to_nifti(input_path, output_file, reorient_nifti, pipeline_name=None):
#     reader = sitk.ImageSeriesReader()
#     dicom_names = reader.GetGDCMSeriesFileNames(str(input_path))
#     ds = series_selector(dicom_names[0], pipeline_name=pipeline_name)
#     reader.SetFileNames(dicom_names)
#     image = reader.Execute()
#     sitk.WriteImage(image, output_file)
#     return ds

# study_names = ['1.2.840.113619.2.25.4.1260288.1278509664.191', '1.2.840.113619.2.327.3.4137921600.124.1407058488.371', '1.2.840.113619.2.334.3.4137913664.424.1466463538.272', '1.2.840.113619.2.55.3.4137898048.540.1264740411.654', '1.2.840.113619.2.55.3.4137913664.869.1301053239.794', '1.2.840.113970.3.57.1.3219726.660248536.20100321.1084131', '1.2.840.113970.3.57.1.3614815.677188018.20100415.1162942', '1.2.840.113970.3.57.1.3763611.696273942.20100514.1122931', '1.2.840.113970.3.57.1.4052749.730108233.20100705.1185125', '1.2.840.113970.3.57.1.4056415.730680166.20100706.1145200', '1.2.840.113970.3.57.1.4405910.770169583.20100903.1163114', '1.2.840.113970.3.57.1.4655468.746054459.20101013.1082134', '1.2.840.113970.3.57.1.49348828.20140501.1152855', '1.2.840.113970.3.57.1.4969094.825298235.20101121.1203449', '1.2.840.113970.3.57.1.49751506.20140729.1100309', '1.2.840.113970.3.57.1.5047382.829836439.20101201.1104716', '1.2.840.113970.3.57.1.5090606.836995318.20101208.1163557', '1.2.840.113970.3.57.1.5124951.841221198.20101214.1121828', '1.2.840.113970.3.57.1.51357670.20150625.1090927', '1.2.840.113970.3.57.1.52787137.20160406.1151608', '1.2.840.113970.3.57.1.55223913.20170707.1104429', '1.2.840.113970.3.57.1.59404158.20190525.1', '1.2.840.113970.3.57.1.62404600.20200917.1092505', '1.2.840.113970.3.57.1.63796608.20210406.1154212', '1.2.840.114350.2.629.2.798268.2.214049946.1', '1.2.840.113619.2.334.3.4137913664.316.1416947176.728', '1.2.840.113619.2.334.3.4137913664.358.1493407736.930', '1.2.840.113619.2.334.3.4137913664.664.1426504723.10', '1.2.840.113619.2.340.3.4137913664.233.1617226394.758', '1.2.840.113619.2.55.3.4137913920.105.1281440647.285', '1.2.840.113619.2.55.3.4137919064.81.1308744113.151', '1.2.840.113970.3.57.1.4340491.763145748.20100824.1160430', '1.2.840.113970.3.57.1.4533761.763631267.20100923.1092253', '1.2.840.113970.3.57.1.4607101.790945843.20101004.1173319', '1.2.840.113970.3.57.1.47689543.20130427.1094829', '1.2.840.113970.3.57.1.48824001.20140107.1201514', '1.2.840.113970.3.57.1.4894117.820442914.20101115.1', '1.2.840.113970.3.57.1.50245280.20141109.1125217', '1.2.840.113970.3.57.1.5047802.831585137.20101201.1121119', '1.2.840.113970.3.57.1.61153789.20200207.1073528', '1.2.840.113619.2.327.3.4137937730.76.1480974569.157', '1.2.840.113619.2.452.3.4137937730.934.1620642878.238', '1.2.840.113619.2.25.1.1762890133.1277399821.101', '1.2.840.113619.2.452.3.4137937730.292.1577705619.326', '1.2.840.113619.2.327.3.4137921600.777.1446791046.827', '1.2.840.113970.3.57.1.2090058.640972004.20100221.1112206', '1.2.840.113970.3.57.1.3697867.688014421.20100502.1095814', '1.2.840.113970.3.57.1.4184890.744374984.20100727.1102449', '1.2.840.113970.3.57.1.4474984.778257809.20100916.1', '1.2.840.113970.3.57.1.4580173.739977092.20100930.1101118', '1.2.840.113970.3.57.1.4767311.809154599.20101029.1223326', '1.2.840.113970.3.57.1.47734138.20130507.1102958', '1.2.840.113970.3.57.1.5198629.847511491.20101222.1115204', '1.2.840.113970.3.57.1.53528987.20160829.1092825', '1.2.840.113970.3.57.1.55414302.20170810.1150932', '1.2.840.113970.3.57.1.58854015.20190305.1124432', '1.2.840.113970.3.57.1.62723936.20201102.1122439', '1.2.840.113970.3.57.1.8483035.20110615.1105311', '1.2.840.113619.2.284.3.4137913664.33.1368186291.228', '1.2.840.113619.2.278.3.4137880131.89.1468934834.80', '1.2.840.113619.2.55.3.4137898048.450.1264404041.826', '1.2.840.113619.2.55.3.4137898048.658.1262581298.908', '1.2.840.113619.2.55.3.4137937730.201.1283370977.950', '1.2.840.113619.2.55.3.4137913920.378.1268400299.589', '1.2.840.113619.2.278.3.4137906246.531.1468000584.70', '1.2.840.113619.2.340.3.4137913664.890.1519920186.497', '1.2.840.113619.2.278.3.4137913920.339.1386073031.685', '1.2.840.113619.2.55.3.4137913664.930.1327929181.89', '1.2.840.113619.2.55.3.4137898048.456.1263960016.452', '1.2.840.113619.2.55.3.4137898048.573.1265688084.446', '1.2.840.113619.2.55.3.4137913920.859.1306152382.176', '1.2.840.113619.2.55.3.4137913920.49.1285760775.796', '1.2.840.113970.3.57.1.3535246.672672494.20100408.1160013', '1.2.840.113970.3.57.1.3881610.709332709.20100603.1185025', '1.2.840.113970.3.57.1.4031281.727355108.20100630.1202446', '1.2.840.113970.3.57.1.4603293.790535781.20101004.1', '1.2.840.113970.3.57.1.47158524.20121128.1144305', '1.2.840.113970.3.57.1.48785022.20131229.1122812', '1.2.840.113970.3.57.1.5050436.831736828.20101201.1145817', '1.2.840.113970.3.57.1.53148032.20160617.1', '1.2.840.113970.3.57.1.56566535.20180228.1132735', '1.2.840.113970.3.57.1.57378602.20180713.1133233', '1.2.840.113970.3.57.1.59456663.20190603.1094141', '1.2.840.113970.3.57.1.64169035.20210527.1142142', '1.2.840.113970.3.57.1.18312951.20111028.1130906', '1.2.840.113619.2.55.1.1762890133.2241.1265487737.860', '1.2.840.113970.3.57.1.3650772.681803841.20100422.1160130', '1.2.840.113970.3.57.1.4363092.765584160.20100827.1204844', '1.2.840.113970.3.57.1.10968887.20110727.1141411', '1.2.840.113970.3.57.1.3981576.721961237.20100623.1', '1.2.840.113970.3.57.1.28751236.20120209.1182132', '1.2.840.113619.2.55.3.4137913920.96.1277898152.206', '1.2.840.113619.2.278.3.4137906246.578.1438645489.621', '1.2.840.113970.3.57.1.41221444.20120422.1140346', '1.2.840.113619.2.327.3.4137937730.712.1485897973.485', '1.2.840.113970.3.57.1.4376710.767124611.20100830.1164402', '1.2.840.113619.2.327.3.4137921600.683.1373108320.118', '1.2.840.113970.3.57.1.4347176.763712103.20100825.1120652', '1.2.840.113619.2.55.3.4137913664.893.1304508347.450', '1.2.840.113970.3.57.1.4317264.760070005.20100819.1185108', '1.2.840.113970.3.57.1.3801003.701358650.20100521.1225024', '1.2.840.113619.2.55.3.4137913920.314.1290601390.805', '1.2.840.113970.3.57.1.3930271.714756367.20100611.1201120', '1.2.840.113619.2.452.3.4137914282.359.1581059411.51', '1.2.840.113970.3.57.1.3606510.676389442.20100414.1153128', '1.2.840.113619.2.452.3.4137937730.626.1613672833.22', '1.2.840.113970.3.57.1.5144643.842690502.20101216.1', '1.2.840.113970.3.57.1.5209269.848820319.20101224.1135258', '1.2.840.113970.3.57.1.5209289.848822640.20101224.1140532', '1.2.840.113970.3.57.1.52319692.20160106.1155357', '1.2.840.113970.3.57.1.53426441.20160809.1165104', '1.2.840.113970.3.57.1.56759505.20180402.1', '1.2.840.113970.3.57.1.56876931.20180420.1111722', '1.2.840.113970.3.57.1.57175539.20180608.1151445', '1.2.840.113970.3.57.1.57442215.20180724.1155158', '1.2.840.113970.3.57.1.63592362.20210309.1151914', '1.2.840.113970.3.57.1.63962688.20210429.1085910', '1.2.840.113619.2.55.3.4137937730.188.1272884760.195', '1.2.840.113619.2.55.3.4137937730.843.1268670391.855', '1.2.840.113619.2.55.1.1762890133.2211.1263495204.338', '1.2.840.113619.2.55.3.4137913920.35.1287056772.543', '1.2.840.113619.2.55.3.4137937730.263.1268327252.380', '1.2.840.113970.3.57.1.4289530.755926672.20100813.1124157', '1.2.840.113970.3.57.1.4063977.731696453.20100707.1230008', '1.2.840.113619.2.55.3.4137898048.323.1263128734.513', '1.2.840.113619.2.25.4.2436394.1351275462.47', '1.2.840.113619.2.55.3.4137937730.383.1346756337.198', '1.2.840.113619.2.452.3.4137937730.880.1597833614.392', '1.2.840.113970.3.57.1.4539852.778443510.20100924.1092158', '1.2.840.113970.3.57.1.47295241.20130108.1095420', '1.2.840.113970.3.57.1.3618662.677151174.20100416.1093839', '1.2.840.113619.2.55.3.4137913664.931.1332848521.360', '1.2.840.113619.2.55.3.4137913920.667.1286544113.306', '1.2.840.113619.2.55.3.4137937730.147.1278416606.583', '1.2.840.113970.3.57.1.49759160.20140730.1150210', '1.2.840.113970.3.57.1.4304392.758425809.20100817.1152934', '1.2.840.113970.3.57.1.5121397.840461285.20101213.1140806', '1.2.840.113970.3.57.1.58163955.20181116.1133327', '1.2.840.113970.3.57.1.61473486.20200329.1094314', '1.2.840.113970.3.57.1.4593289.789341784.20101001.1210500', '1.2.840.113619.2.284.3.4137913664.228.1343342467.42', '1.2.840.113970.3.57.1.4826969.814282415.20101106.1', '1.2.840.113970.3.57.1.3935354.715563740.20100613.1115925', '1.2.840.113970.3.57.1.49261025.20140414.1', '1.2.840.113619.2.452.3.4137919146.647.1598351842.945', '1.2.840.113970.3.57.1.4773560.809560722.20101030.1175440', '1.2.840.113970.3.57.1.49670558.20140711.1091510', '1.2.840.113970.3.57.1.49408784.20140514.1151454', '1.2.840.113970.3.57.1.48169266.20130814.1180728', '1.2.840.113619.2.327.3.4137921600.444.1461646005.589', '1.2.840.113970.3.57.1.4169740.742624341.20100724.1104442', '1.2.840.113970.3.57.1.49246916.20140410.1112156', '1.2.840.113619.2.55.3.4137913920.134.1285676575.643', '1.2.840.113970.3.57.1.3737498.693550900.20100510.1224704', '1.2.840.113619.2.55.3.4137937730.357.1273688089.806', '1.2.840.113970.3.57.1.55140765.20170621.1143629', '1.2.840.113970.3.57.1.5574721.883536255.20110210.1', '1.2.840.113970.3.57.1.58917438.20190314.1130243', '1.2.840.113970.3.57.1.60344320.20191014.1093349', '1.2.840.113970.3.57.1.64865302.20210903.1102916', '1.2.840.113970.3.57.1.53951437.20161115.1', '1.2.840.113970.3.57.1.12847237.20110820.1164653', '1.2.840.113970.3.57.1.4184010.744289415.20100727.1', '1.2.840.113970.3.57.1.4317421.760163336.20100819.1211321', '1.2.840.113619.2.278.3.4137913920.64.1347622042.682', '1.2.840.113619.2.327.3.4137921600.37.1376025372.795', '1.2.840.113970.3.57.1.4875594.818249654.20101111.1160125', '1.2.840.113970.3.57.1.5004044.828173307.20101126.1', '1.2.840.113970.3.57.1.60366936.20191016.1141224', '1.2.840.113970.3.57.1.4346830.757692441.20100825.1110826', '1.2.840.113970.3.57.1.2010120.633457675.20100210.1082137', '1.2.840.113619.2.55.3.4137898048.323.1263128740.296', '1.2.840.113619.2.55.1.1762890133.2242.1271248808.986', '1.2.840.113619.2.55.3.4137898048.663.1262842370.331', '1.2.840.113970.3.57.1.5122579.840755650.20101213.1210058', '1.2.840.113970.3.57.1.62320559.20200904.1123949', '1.2.840.113619.2.55.3.4137898048.450.1264404042.26', '1.2.840.113970.3.57.1.50969675.20150407.1160416', '1.2.840.113619.2.55.3.4137937730.95.1274890075.331']


def dicom_series_to_nifti(input_path, output_file, reorient_nifti, pipeline_name=None):
    # split input path to get study name
    print("Input path")
    print(str(input_path))
    reader = sitk.ImageSeriesReader()
    dicom_names = reader.GetGDCMSeriesFileNames(str(input_path))

    expected_size = [512, 512, 1]
    valid_dicom_names = []

    for dicom_name in dicom_names:
        ds = pydicom.dcmread(dicom_name)
        rows, cols = ds.Rows, ds.Columns

        if rows == expected_size[0] and cols == expected_size[1]:
            valid_dicom_names.append(dicom_name)
        else:
            print(f"Skipping {dicom_name} due to size mismatch: {rows}x{cols}")

    if not valid_dicom_names:
        raise RuntimeError("No valid DICOM files found with the expected size.")

    reader.SetFileNames(valid_dicom_names)
    image = reader.Execute()
    sitk.WriteImage(image, output_file)

    ds = series_selector(valid_dicom_names[0], pipeline_name=pipeline_name)
    return ds
